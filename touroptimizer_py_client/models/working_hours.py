# coding: utf-8

"""
    DNA Evolutions - JOpt.TourOptimizer

    This is DNA's JOpt.TourOptimizer service. A RESTful Spring Boot application using springdoc-openapi and OpenAPI 3. JOpt.TourOptimizer is a service that delivers route optimization and automatic scheduling features to be easily integrated into any third-party application. JOpt.TourOptimizer encapsulates all necessary optimization functionality and provides a comprehensive REST API that offers a domain-specific optimization interface for the transportation industry. The service is stateless and does not come with graphical user interfaces, map depiction or any databases. These extensions and adjustments are supposed to be introduced by the consumer of the service while integrating it into his/her own application. The service will allow for many suitable adjustments and user-specific settings to adjust the behaviour and optimization goals (e.g. minimizing distance, maximizing resource utilization, etc.) through a comprehensive set of functions. This will enable you to gain control of the complete optimization processes.This service is based on JOpt (7.5.1-rc3-j17-SNAPSHOT)

    The version of the OpenAPI document: unknown
    Contact: info@dna-evolutions.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from touroptimizer_py_client.models.constraint import Constraint
from touroptimizer_py_client.models.node_color_capacity import NodeColorCapacity
from touroptimizer_py_client.models.qualification import Qualification
from touroptimizer_py_client.models.reduced_node_edge_connector_item import ReducedNodeEdgeConnectorItem
from touroptimizer_py_client.models.start_reduction_time_definition import StartReductionTimeDefinition
from touroptimizer_py_client.models.start_reduction_time_include_definition import StartReductionTimeIncludeDefinition
from touroptimizer_py_client.models.start_reduction_time_pillar_definition import StartReductionTimePillarDefinition
from touroptimizer_py_client.models.stay_out_cycle_definition import StayOutCycleDefinition
from typing import Optional, Set
from typing_extensions import Self

class WorkingHours(BaseModel):
    """
    The list of non-overlapping workingHours.
    """ # noqa: E501
    begin: datetime = Field(description="The begin of the Working hours.")
    end: datetime = Field(description="The end of the Working hours.")
    zone_id: StrictStr = Field(description="The zoneId of the Working hours.", alias="zoneId")
    max_time: Optional[StrictStr] = Field(default=None, description="The maximal time a Resource should work within the WorkingHour.", alias="maxTime")
    max_distance: Optional[StrictStr] = Field(default=None, description="The maximla distance a resource should cover within the WorkingHour.", alias="maxDistance")
    stay_out_cycle_definition: Optional[StayOutCycleDefinition] = Field(default=None, alias="stayOutCycleDefinition")
    start_reduction_time_definition: Optional[StartReductionTimeDefinition] = Field(default=None, alias="startReductionTimeDefinition")
    start_reduction_time_pillar_definition: Optional[StartReductionTimePillarDefinition] = Field(default=None, alias="startReductionTimePillarDefinition")
    start_reduction_time_include_definition: Optional[StartReductionTimeIncludeDefinition] = Field(default=None, alias="startReductionTimeIncludeDefinition")
    local_flex_time: Optional[StrictStr] = Field(default=None, description="The local flexible time. In some cases a Resource should start working later compared to what is defined in the working hours. This way idle time can be reduced. The local flex time is the maximum a Resource is allowed to start working later, depending on the Optimization maybe flex time is not or only partially used.", alias="localFlexTime")
    local_post_flex_time: Optional[StrictStr] = Field(default=None, description="The localPostFlexTime", alias="localPostFlexTime")
    local_post_flex_time_only_on_overtime: Optional[StrictBool] = Field(default=False, description="The post flextime is only applied to reduce overtime.", alias="localPostFlexTimeOnlyOnOvertime")
    max_local_pillar_after_hours_time: Optional[StrictStr] = Field(default=None, description="The maxLocalPillarAfterHoursTime", alias="maxLocalPillarAfterHoursTime")
    node_color_capacities: Optional[List[NodeColorCapacity]] = Field(default=None, description="The nodeColorCapacities", alias="nodeColorCapacities")
    working_hours_constraints: Optional[List[Constraint]] = Field(default=None, description="The constraints for this working hour.", alias="workingHoursConstraints")
    multi_working_hours_constraints: Optional[List[Constraint]] = Field(default=None, description="The multiWorkingHoursConstraints", alias="multiWorkingHoursConstraints")
    qualifications: Optional[List[Qualification]] = Field(default=None, description="The qualification of the Resource for this working hour. For example, the Resource is allowed to visit a node needing a skill (defined via a constraint) and the Resource is providing this skill.")
    route_start_time_hook: Optional[StrictStr] = Field(default=None, description="The routeStartTimeHook", alias="routeStartTimeHook")
    hook_element_connections: Optional[List[ReducedNodeEdgeConnectorItem]] = Field(default=None, description="The list of hook connections", alias="hookElementConnections")
    is_closed_route: Optional[StrictBool] = Field(default=True, description="The isClosedRoute boolean describes if a Resource has to visit the termination element of the Route. By default, the start element and the termination element of a Route is the Resource itself. In case of a closed route, by default, the Resource returns to its original starting location.", alias="isClosedRoute")
    is_available_for_stay: Optional[StrictBool] = Field(default=True, description="The boolean isAvailableForStay defines if this working hour is allowed to end at an overnight stay.", alias="isAvailableForStay")
    __properties: ClassVar[List[str]] = ["begin", "end", "zoneId", "maxTime", "maxDistance", "stayOutCycleDefinition", "startReductionTimeDefinition", "startReductionTimePillarDefinition", "startReductionTimeIncludeDefinition", "localFlexTime", "localPostFlexTime", "localPostFlexTimeOnlyOnOvertime", "maxLocalPillarAfterHoursTime", "nodeColorCapacities", "workingHoursConstraints", "multiWorkingHoursConstraints", "qualifications", "routeStartTimeHook", "hookElementConnections", "isClosedRoute", "isAvailableForStay"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WorkingHours from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of stay_out_cycle_definition
        if self.stay_out_cycle_definition:
            _dict['stayOutCycleDefinition'] = self.stay_out_cycle_definition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_reduction_time_definition
        if self.start_reduction_time_definition:
            _dict['startReductionTimeDefinition'] = self.start_reduction_time_definition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_reduction_time_pillar_definition
        if self.start_reduction_time_pillar_definition:
            _dict['startReductionTimePillarDefinition'] = self.start_reduction_time_pillar_definition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of start_reduction_time_include_definition
        if self.start_reduction_time_include_definition:
            _dict['startReductionTimeIncludeDefinition'] = self.start_reduction_time_include_definition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in node_color_capacities (list)
        _items = []
        if self.node_color_capacities:
            for _item_node_color_capacities in self.node_color_capacities:
                if _item_node_color_capacities:
                    _items.append(_item_node_color_capacities.to_dict())
            _dict['nodeColorCapacities'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in working_hours_constraints (list)
        _items = []
        if self.working_hours_constraints:
            for _item_working_hours_constraints in self.working_hours_constraints:
                if _item_working_hours_constraints:
                    _items.append(_item_working_hours_constraints.to_dict())
            _dict['workingHoursConstraints'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in multi_working_hours_constraints (list)
        _items = []
        if self.multi_working_hours_constraints:
            for _item_multi_working_hours_constraints in self.multi_working_hours_constraints:
                if _item_multi_working_hours_constraints:
                    _items.append(_item_multi_working_hours_constraints.to_dict())
            _dict['multiWorkingHoursConstraints'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in qualifications (list)
        _items = []
        if self.qualifications:
            for _item_qualifications in self.qualifications:
                if _item_qualifications:
                    _items.append(_item_qualifications.to_dict())
            _dict['qualifications'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hook_element_connections (list)
        _items = []
        if self.hook_element_connections:
            for _item_hook_element_connections in self.hook_element_connections:
                if _item_hook_element_connections:
                    _items.append(_item_hook_element_connections.to_dict())
            _dict['hookElementConnections'] = _items
        # set to None if local_post_flex_time_only_on_overtime (nullable) is None
        # and model_fields_set contains the field
        if self.local_post_flex_time_only_on_overtime is None and "local_post_flex_time_only_on_overtime" in self.model_fields_set:
            _dict['localPostFlexTimeOnlyOnOvertime'] = None

        # set to None if is_closed_route (nullable) is None
        # and model_fields_set contains the field
        if self.is_closed_route is None and "is_closed_route" in self.model_fields_set:
            _dict['isClosedRoute'] = None

        # set to None if is_available_for_stay (nullable) is None
        # and model_fields_set contains the field
        if self.is_available_for_stay is None and "is_available_for_stay" in self.model_fields_set:
            _dict['isAvailableForStay'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WorkingHours from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "begin": obj.get("begin"),
            "end": obj.get("end"),
            "zoneId": obj.get("zoneId"),
            "maxTime": obj.get("maxTime"),
            "maxDistance": obj.get("maxDistance"),
            "stayOutCycleDefinition": StayOutCycleDefinition.from_dict(obj["stayOutCycleDefinition"]) if obj.get("stayOutCycleDefinition") is not None else None,
            "startReductionTimeDefinition": StartReductionTimeDefinition.from_dict(obj["startReductionTimeDefinition"]) if obj.get("startReductionTimeDefinition") is not None else None,
            "startReductionTimePillarDefinition": StartReductionTimePillarDefinition.from_dict(obj["startReductionTimePillarDefinition"]) if obj.get("startReductionTimePillarDefinition") is not None else None,
            "startReductionTimeIncludeDefinition": StartReductionTimeIncludeDefinition.from_dict(obj["startReductionTimeIncludeDefinition"]) if obj.get("startReductionTimeIncludeDefinition") is not None else None,
            "localFlexTime": obj.get("localFlexTime"),
            "localPostFlexTime": obj.get("localPostFlexTime"),
            "localPostFlexTimeOnlyOnOvertime": obj.get("localPostFlexTimeOnlyOnOvertime") if obj.get("localPostFlexTimeOnlyOnOvertime") is not None else False,
            "maxLocalPillarAfterHoursTime": obj.get("maxLocalPillarAfterHoursTime"),
            "nodeColorCapacities": [NodeColorCapacity.from_dict(_item) for _item in obj["nodeColorCapacities"]] if obj.get("nodeColorCapacities") is not None else None,
            "workingHoursConstraints": [Constraint.from_dict(_item) for _item in obj["workingHoursConstraints"]] if obj.get("workingHoursConstraints") is not None else None,
            "multiWorkingHoursConstraints": [Constraint.from_dict(_item) for _item in obj["multiWorkingHoursConstraints"]] if obj.get("multiWorkingHoursConstraints") is not None else None,
            "qualifications": [Qualification.from_dict(_item) for _item in obj["qualifications"]] if obj.get("qualifications") is not None else None,
            "routeStartTimeHook": obj.get("routeStartTimeHook"),
            "hookElementConnections": [ReducedNodeEdgeConnectorItem.from_dict(_item) for _item in obj["hookElementConnections"]] if obj.get("hookElementConnections") is not None else None,
            "isClosedRoute": obj.get("isClosedRoute") if obj.get("isClosedRoute") is not None else True,
            "isAvailableForStay": obj.get("isAvailableForStay") if obj.get("isAvailableForStay") is not None else True
        })
        return _obj


